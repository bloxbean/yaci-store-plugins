/**
 * Yaci Store UTXO Plugin Script
 * This script provides functionality for filtering UTXOs by address before storing in address_utxo table.
 * It also remove extra tx_inputs records through handling commit events
 */

/**
 * Filters a list of UTXO items by a specific address
 * @param items - List of UTXO items to filter
 * @return List of filtered UTXOs that match the address filter
 */
def filterByAddress(items) {
    // Initialize empty list to store filtered results
    filteredUtxos = [];
    
    // Get the address filter from environment configuration
    address = env.getProperty("address.filter");
    
    // Iterate through all UTXO items and filter by owner address
    for (item: items) {
        if (item.ownerAddr == address) {
            filteredUtxos.add(item);
        }
    }
    
    // If any UTXOs were found, update global state and log the count
    if (filteredUtxos.size() > 0) {
        global_state.put("utxo.found", true);
    }
    
    return filteredUtxos;
}

/**
 * Handles commit events by cleaning up additional transaction inputs
 * 
 * Since tx_input records don't have address filtering and Yaci Store processes 
 * blocks in parallel batches (100 blocks during initial sync, 1 block at tip), tx_input 
 * records may be inserted before their corresponding UTXO entries in address_utxo table. 
 * The CommitEvent is published at the end of each batch and handlers are processed 
 * sequentially, making it the perfect place to delete orphaned tx_input records.
 * 
 * @param event - The commit event containing metadata like slot number
 */
def handleCommitEvent(event) {
    // Get the last processed slot from state, default to 0 if not set
    // In this case, we are using plugin state to store last_tx_input_slot
    last_tx_inputs_slot = global_state.get("last_tx_inputs_slot");
    if (last_tx_inputs_slot == null) {
        last_tx_inputs_slot = 0;
    }

    System.out.println("Deleting additional tx inputs after slot: " + last_tx_inputs_slot);

    // SQL query to delete orphaned tx_input records
    // Only deletes records that are not referenced by address_utxo table
    sql = "DELETE FROM tx_input ti " +
            "WHERE ti.spent_at_slot > :given_slot " +
            "AND NOT EXISTS ( " +
            "  SELECT 1 FROM address_utxo au " +
            "  WHERE au.tx_hash = ti.tx_hash " +
            "    AND au.output_index = ti.output_index " +
            ")";

    // Set parameters for the SQL query
    params = [ "given_slot" : last_tx_inputs_slot ];
    
    // Execute the delete operation and get count of deleted records
    count = named_jdbc.update(sql, params);

    // Log the number of deleted records if any were found
    if (count > 0) {
        System.out.println("Deleted " + count + " additional tx inputs.");
    }

    // Update the last processed slot to current event slot
    global_state.put("last_tx_inputs_slot", event.metadata.slot);
}

def handleRollbackEvent(event) {
    //Reset last_tx_input_slot
    System.out.println("Utxo by address plugin handleRollbackEvent: " + event.rollbackTo.slot);
    global_state.put("last_tx_inputs_slot", event.rollbackTo.slot);
}

def sendDiscordNotificationOnBalanceChange(event) {
    utxoFound = global_state.get("utxo.found");
    
    if (utxoFound != null && utxoFound) {
        global_state.remove("utxo.found");

        // Skip sending notification if not at tip yet
        if (!event.metadata.syncMode) {
            return;
        }

        address = env.getProperty("address.filter");    

        sql = "SELECT SUM(au.lovelace_amount) AS balance " +
            "FROM address_utxo au " +
            "WHERE au.owner_addr = :address " +
            "AND NOT EXISTS (SELECT 1 FROM tx_input ti WHERE ti.tx_hash = au.tx_hash AND ti.output_index = au.output_index)";

        params = [ "address" : address ];
        
        result = named_jdbc.queryForMap(sql, params);
        balance = result["balance"];

        discordUrl = env.getProperty("discord.webhook.url");

        jsonData = ["content": "ðŸ’° Unspent UTXO Balance: " + balance + " Lovelace at Block: " + event.metadata.block +"\n Address: " + address];
        response = http.postJson(discordUrl, jsonData, ["Content-Type": "application/json"]);
        System.out.println("Discord response: " + response);
    }
}